from typing import Optional, Tuple

from google.cloud.firestore import DocumentSnapshot, CollectionReference, Query

from flask_boiler.query import cmp
from flask_boiler.utils import snapshot_to_obj


def is_fb_snapshot(snapshot: DocumentSnapshot) -> bool:
    """
    Returns true if a snapshot is generated by flask-boiler
        (checks if obj_type exists)

    :param snapshot:
    :return:
    """
    try:
        _ = snapshot.get("obj_type")
        return True
    except KeyError as ke:
        return False


def convert_query_ref(func):
    """
    Converts a generator of firestore DocumentSnapshot's to a generator
            of objects.

    :param super_cls:
    """
    def call(cls, *args, **kwargs):
        query_ref = func(cls, *args, **kwargs)
        for res in query_ref.stream():
            assert isinstance(res, DocumentSnapshot)
            # if is_fb_snapshot(snapshot=res):
            #     # Skip this snapshot if it is not generated by flask-boiler
            yield snapshot_to_obj(snapshot=res, super_cls=cls)
    return call


class QueryMixin:
    @classmethod
    def all(cls):
        """ Gets object that is a subclass of the current cls in
                the collection.

        """

        q = cls.get_query()
        docs = q.stream()
        for doc in docs:
            assert isinstance(doc, DocumentSnapshot)
            # if is_fb_snapshot(snapshot=doc):
            #     # Skip this snapshot if it is not generated by flask-boiler
            #     # TODO: redesign this behavior
            #     # TODO: note that number of documents returned will be
            #     #           affected
            yield snapshot_to_obj(snapshot=doc, super_cls=cls)

    @staticmethod
    def _append_original(*args, cur_where=None) -> Query:
        if cur_where is None:
            raise ValueError

        if len(args) != 0:
            if len(args) % 3 != 0:
                raise ValueError
            else:
                arg_stack = list( args )

                while len(arg_stack) != 0:

                    cur_where = cur_where.where(
                        arg_stack.pop(0),
                        arg_stack.pop(0),
                        arg_stack.pop(0)
                    )
        return cur_where

    @classmethod
    def _append_new_style(cls, *, cur_where=None, **kwargs):
        if cur_where is None:
            raise ValueError

        for key, val in kwargs.items():
            comp, other = val if isinstance(val, tuple) else ("==", val)
            firestore_key = cls.get_schema_cls().f(key)
            cur_where = cur_where.where(firestore_key, comp, other)
        return cur_where

    @classmethod
    def _append_cmp_style(cls, *args, cur_where=None):

        if cur_where is None:
            raise ValueError

        if len(args) != 0:

            arg_stack = list( args )

            while len(arg_stack) != 0:

                condition = arg_stack.pop(0)
                key = condition.fieldname
                firestore_key = cls.get_schema_cls().f(key)

                for comp, other in condition.constraints:
                    if comp == "_in":
                        # Reverse argument order for "in" comparator
                        cur_where = cur_where.where(
                            other, "in", firestore_key)
                    else:
                        # Append comparator for normal cases
                        cur_where = cur_where.where(
                            firestore_key, comp, other)

        return cur_where

    @classmethod
    def _where_query(cls, *args, cur_where=None, **kwargs):
        # if len(args) == 0 and len(kwargs) == 0:
        #     raise ValueError("Empty where")
        if cur_where is None:
            raise ValueError

        cmp_args = [arg for arg in args if isinstance(arg, cmp.Condition)]
        remaining_args = [arg for arg in args
                          if not isinstance(arg, cmp.Condition)]
        cur_where = cls._append_cmp_style(*cmp_args, cur_where=cur_where)
        cur_where = cls._append_original(*remaining_args, cur_where=cur_where)
        cur_where = cls._append_new_style(**kwargs, cur_where=cur_where)
        return cur_where

    @classmethod
    def get_obj_type_condition(cls) -> Optional[Tuple]:
        schema_obj = cls.get_schema_obj()
        if 'obj_type' not in schema_obj.fields:
            return None
        else:
            data_key = schema_obj.fields['obj_type'].get_obj_type_data_key()
            if data_key is None:
                return None
            else:
                return ("obj_type", "in", cls._get_subclasses_str())

    @classmethod
    def get_query(cls):
        """ Returns a query with parent=cls._get_collection(), and
                limits to obj_type of subclass of cls.
        """
        cur_where = Query(parent=cls._get_collection(),
                          # TODO: pass caught kwargs to Query constructor
                          )
        condition = cls.get_obj_type_condition()
        if condition is not None:
            cur_where = cur_where.where(*condition)
        return cur_where

    @classmethod
    @convert_query_ref
    def where(cls, *args,
              acsending=None,
              descending=None,
              end_at=None,
              end_before=None,
              limit=None,
              offset=None,
              order_by=None,
              select=None,
              start_after=None,
              start_at=None,
              **kwargs,):
        """ Queries the datastore. Note that indexes may need to be added
                from the link provided by firestore in the error messages.

        NOTE: all subclasses of the current class will be queried
        NOTE: this method will fail when the descendents of the class
            plus itself counts to >10 due to Firestore query limitation.
            (10 "in" queries max, which is 9 descendant classes max).
            Watch for dynamically constructed class
            in runtime, as this may increase the number of descendants of its
            superclass, and may result in fail. To turn off obj_type behavior,
            use a separate collection for each class and/or customize
            obj_type field/attribute.

        TODO: post more examples for customizing obj_type field/attribute

        TODO: add error handling and argument checking
        TODO: implement limit, orderby, etc.

        :param args:
        :param kwargs:
        """

        cur_where = cls._where_query(*args, **kwargs,
                                     cur_where=cls.get_query())

        if limit is not None:
            cur_where = cur_where.limit(count=limit)

        return cur_where
