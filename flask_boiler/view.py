from flasgger import SwaggerView
from flask import jsonify

from .serializable import Serializable
from .domain_model import DomainModel
from .view_model import ViewModel, ViewModelMixin
from google.cloud import firestore
from .context import Context as CTX


class FlaskAsViewMixin:

    @classmethod
    def get(cls, struct_d=None):
        obj = cls(struct_d=struct_d)
        for key, val in obj._structure.items():
            obj_type, doc_id, update_func = val
            obj.quick_bind_to(key=key, obj_type=obj_type, doc_id=doc_id)
        return obj

    def new(cls, *args, **kwargs):
        raise NotImplementedError

    def get_on_update(self,
                  dm_cls=None, dm_doc_id=None,
                  update_func=None, key=None):
        # do something with this ViewModel

        def __on_update(dm: DomainModel):

            update_func(vm=self, dm=dm)

            self.business_properties[key] = dm

        return __on_update

    def quick_bind_to(self, key, obj_type, doc_id):
        """

        :param key:
        :param obj_type:
        :param doc_id:
        :return:
        """
        obj_cls: DomainModel = Serializable.get_cls_from_name(obj_type)
        obj = obj_cls.get(doc_id=doc_id)
        update_func = self._structure[key][2]
        f = self.get_on_update(dm_cls=obj_cls, dm_doc_id=doc_id,
                  update_func=update_func, key=None)
        f(obj)


def default_mapper(path_str_template: str, _kwargs):
    """

    :param path_str_template: example "company/{}"
    :param args: example ["users"]
    :return: DocumentReference for "company/users"
    """
    """
    Maps a list of arguments from flask.View().get(args) to
        a firestore reference that is used to construct
        the ReferencedObject document
    :return:
    """
    path_str = path_str_template.format(**_kwargs)
    path = CTX.db.document(path_str)
    return path


def flask_as_view(view_model_cls: ViewModel,
                  domain_model_cls: DomainModel,
                     app,
                     endpoint,
                     description=None):
    _proxy_view_cls_name = "{}ProxyView".format(view_model_cls.__name__)

    if description is None:
        description = "A REST API resource automatically generated by" \
                      " flask-boiler"

    responses = {
        200: {
            "description": description,
            "schema": view_model_cls.get_schema_cls()
        }
    }

    parameters = [
        {
            "name": "doc_id",
            "in": "path",
            "type": "string",
            "enum": ["all", "palette_id_a",
                     "palette_id_b"],
            "required": True,
            "default": "all"
        }
    ]

    def get(self, **kwargs):

        obj_gen = domain_model_cls.where(**kwargs)

        objs = [ obj for obj in obj_gen ]

        vm = view_model_cls.from_dict(
            dict(luggages=objs)
        )

        return jsonify(vm.to_dict())

    # Dynamically construct a proxy class that has responses static var
    proxy_view_cls = type(_proxy_view_cls_name,  # class name
                          (SwaggerView,),
                          dict(
                               responses=responses,
                               parameters=parameters,
                               _view_model_cls=view_model_cls,
                               get=get
                               )
                          )

    rule = endpoint

    app.add_url_rule(
        rule,
        view_func=proxy_view_cls.as_view(proxy_view_cls.__name__),
        methods=['GET']
    )

    return proxy_view_cls


def document_as_view(view_model_cls,
                     app,
                     endpoint,
                     mapper,
                     description=None):
    """ Registers a view model as a REST API resource and generate
            corresponding documentation.

    :param view_model_cls: class of view model
    :param app: flask app instance
    :param mapper: function which receives kwargs from REST endpoint and
                    returns a firestore document reference
    :param endpoint: Flask app endpoint for add_url_rule
    :param description: description of the REST API resource for generating
                    flasgger documentations
    :return: proxy flask view
    """


    # Note that there are better ways of implementing this
    _proxy_view_cls_name = "{}ProxyView".format(view_model_cls.__name__)

    if description is None:
        description = "A REST API resource automatically generated by" \
                      " flask-boiler"

    responses = {
        200: {
            "description": description,
            "schema": view_model_cls.get_schema_cls()
        }
    }

    parameters = [
        {
            "name": "doc_id",
            "in": "path",
            "type": "string",
            "enum": ["all", "palette_id_a",
                     "palette_id_b"],
            "required": True,
            "default": "all"
        }
    ]

    def get(self, **kwargs):
        doc_ref: firestore.DocumentReference = mapper(kwargs)

        obj = self._view_model_cls.get(doc_ref=doc_ref)
        return jsonify(obj.to_dict())

    # Dynamically construct a proxy class that has responses static var
    proxy_view_cls = type(_proxy_view_cls_name,  # class name
                          (SwaggerView,),
                          dict(
                               responses=responses,
                               parameters=parameters,
                               _view_model_cls=view_model_cls,
                               get=get
                               )
                          )

    rule = endpoint

    app.add_url_rule(
        rule,
        view_func=proxy_view_cls.as_view(proxy_view_cls.__name__),
        methods=['GET']
    )

    return proxy_view_cls


class GenericView(SwaggerView):

    _view_model_cls = None
    # responses = dict()

    def __new__(cls, view_model_cls: ViewModel=None, description=None, *args, **kwargs):
        """
        TODO: test
        Note that this implementation is unstable.

        :param view_model_cls:
        :param args:
        :param kwargs:
        :return:
        """

        instance = super().__new__(cls)

        cls._view_model_cls = view_model_cls

        # cls.responses = {
        #     200: {
        #         "description": str() if description is None else description,
        #         "schema": cls._view_model_cls.schema_cls
        #     }
        # }

        return instance

    def get(self, dev_path):

        doc_ref: firestore.DocumentReference = \
            firestore.DocumentReference(dev_path)

        assert callable(self._view_model_cls)

        view_model_obj = self._view_model_cls(doc_ref=doc_ref)

        assert isinstance(view_model_obj, ViewModel)

        return view_model_obj.to_dict()
